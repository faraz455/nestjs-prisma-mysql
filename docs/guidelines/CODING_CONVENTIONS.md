## General  Guidelines:

-   **Readability**: Use clear and concise language.
Break down complex points into smaller sections.
-   **Structure**: Group related items logically.
Use consistent formatting for code examples. Add clear headers for sections and points.
-   **Emphasis**: Bold or italicize key terms or concepts. Use bulleted lists for easier scanning.
-   **Use Prettier for consistent code formatting.**

## Formatting

This project uses Prettier for code formatting. Please ensure your code adheres to the Prettier style guide before submitting any pull requests.


## Specific Enhancements by section:
### DTO/Entity files 

-   **Enforce Validator-Type Compatibility**: Ensure each validator aligns with the corresponding TypeScript datatype for accurate validation.
-   **Harmonize ApiProperty with Optionality**: Align the `required` argument of `ApiProperty` with the presence or absence of `@IsOptional` and the "?" symbol to ensure consistent API behavior.
-   **Validate Nested DTOs Comprehensively**: Apply `@ValidateNested({ each: true })` to arrays of nested DTOs to validate each element individually. Use the `Type` transformer to specify the nested DTO type for accurate validation. 

## Service files 

-   **Scrutinize conditional logic**: Carefully examine the use of if statements and ternary operators within the service code to ensure they function as intended and avoid potential issues.
-   **Prevent null/undefined access errors**: Employ optional chaining (the ?. operator) to safely access properties of variables that might be null or undefined, preventing potential internal server errors.
-   **Ensure API response consistency**: For service functions directly called by controllers, verify that the returned object accurately reflects the expected structure of the API response. If the service updates an entity, confirm that the corresponding entity in the database is also updated accordingly.
-   **Enforce transactional consistency**: Guarantee that all database write operations within an endpoint are executed within a transaction to maintain data integrity. Reads can occur outside the transaction, but any reads after the transaction begins must be included within it.
-   **Handle missing Patch/Update keys**: Acknowledge that Patch/Update requests might not provide all keys present in the DTO (Data Transfer Object). Ensure the code doesn't rely on specific keys being present. If necessary, implement checks (e.g., if statements) to handle missing keys gracefully.

## Controller files 

1. Make sure that any endpoints with path variables are listed BELOW endpoints with the same method that have the same route before the variable. For example: "@Get('foo/:id')" must be BELOW "@Get('foo/bar')". 

2. Make sure the ApiResponse type entity is correct. It should be the same as the return type of the service function which this controller function calls. 

## Migrations

It is **EXTREMELY important to review migrations**. This is because a failed migration on production can be difficult to recover from. As a general rule, migrations will have been generated by Prisma and will be perfectly safe. The following conditions must be catered to: 

1. **If the migration modifies data:** This will usually be done with an update query. In this situation, you must invariably discuss what the migration intends with its author and then try to make sure that it really does what it intends. 

2. **If the migration adds a non-nullable column to a table which already contains data**: Here, the Prisma-generated migration is of absolutely NO USE. The migration MUST be written by hand. The column must first be created as a nullable column, data must be entered into it in such a manner that GUARANTEES that every existing row gets an entry, and finally, it must be modified and marked non-nullable. This must all happen inside the same migration file. 

3. **As a general rule**: Make sure that only one migration file is associated with a single PR, otherwise things will get out of hand very quickly. If a PR contains multiple migration files.

4. **Change in schema**: It must include the relevant migrations files for that schema change. 